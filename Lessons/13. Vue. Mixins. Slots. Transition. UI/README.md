### 1. Примеси (mixins)

Дублирование кода - почти всегда антипаттерн. Общую логику компонентов можно вынести в
примесь - объект, который будет "подмешивать" свои свойства к каждому экземпляру, куда он
будет добавлен как миксин (примесь). Миксины возможно использовать как в `html`, так и в
однофайловых компонентах `.vue`.

Миксины могут иметь тот же набор свойств, что и любой другой экземпляр `Vue` - данные,
методы, вычисляемые свойства и т.д.

Разберем пример создания примеси для вывода массива ошибок пользователю:

```
<div id="app">
    <button
        @click="showErrors(errors)"
        class="btn btn-warning"
    >
        Вызвать миксин!
    </button>
</div>

<script>
    const errorsMixin = {
        methods: {
            showErrors(errors) {
                const errorsText = 'Внимание! ' + errors.join('. ');
                alert(errorsText);
            },
        },
    };
    
    const app = new Vue({
        el: '#app',
        mixins: [ errorsMixin ],
        data() {
            return {
                errors: [ 'Пароль неверный', 'Телефон неверный', 'Вообще все неверно, парень..' ],
            };
        },
    });
</script>
```

В данном случае мы "подмешиваем" миксин `errorsMixin` с его методом `showErrors`, который
теперь доступен в самом компоненте. <br> Удобство заключается в том, что теперь данный
метод можно подключить к любому экземпляру `Vue` одной строкой.

При конфликте слияния (когда в компоненте уже есть подмешиваемые сущности) `Vue`
объединяет опции. <br>
Например, `data` компонента сливается с `data` примеси, при этом данные самого компонента
имеют более высокий приоритет. <br>
Если в миксине и компоненте есть одноименный метод, более высокий приоритет опять же имеет
метод из компонента. <br>
Хуки жизненного цикла же объединяются (сначала содержимое хука в примеси, затем идет
содержимое хука компонента)

***

### 2. Model

Как уже было рассказано на предыдущих занятиях, директива `v-model` служит для
динамической связки тегов в шаблоне и данных в экземпляре компонента:

```
<input type="text" v-model="name">

...
data() {
    return {
        name: '',
    }
}
...
```

Однако помимо простой связки с каким-либо тегом в шаблоне можно использовать `v-model` и
на компонентах:

```
<CommonBlock v-model="name">

...
data() {
    return {
        name: '',
    }
}
...
```

**Эта запись - просто синтаксический сахар над более полным вариантом:**

```
<CommonBlock :value="name" @input="val => { name = val }" />
```

То есть в компонент в качестве пропа передается ключ `value`, а обратно в текущий
компонент данные возвращаются с помощью отправки события `input`. В дочернем компоненте
это будет выглядеть следующим образом:

```
<template>
    <input
        :value="value"              - передаем полученное value в поле ввода
        type="text"
        @input="handleInputName"    - обрабатываем событие ввода текста
    >
</template>


<script>
export default {
    props: {
        value: String,                      // получаем value
    },
    methods: {
        handleInputName(value) {
            this.$emit('input', value);     // отправляем value в родительский компонент
        }
    }
}
</script>
```

Однако у `v-model` в контексте работы с компонентами есть и интересная особенность. <br>
Если проп `value` и событие `input` внутри компонента там нужны для чего-то еще, мы можем
переопределить имя ключа и событие для работы директивы `v-model`:

В дочернем компоненте добавляем секцию `model`:

```
<script>
export default {
    model: {
        prop: 'name',       // определяем имя пропа для работы с v-model
        event: 'change',    // определяем событие для работы с v-model
    },
    props: {
        name: {
            type: String,
            default: ''
        },
        // Теперь проп value можно использовать в других целях (он больше не привязан к v-model)
        value: {
            type: Boolean,
            default: false
        }
    },
    methods: {
        handleInputName(value) {
            this.$emit('change', value);     // отправляем value в v-model через change
        }
    }
```

В родительском компоненте это будет выглядеть следующим образом:

```
<CommonBlock :value="isPopupVisible" v-model="name" />
```

Эта запись эквивалента следующей:

```
<CommonBlock
    :name="name"
    :value="isPopupVisible"
    @change="val => { name = val }"
/>
```

***

### 3. Vue libraries

Экосистема `Vue` состоит из нескольких библиотек, поддерживаемых разработчиками
самого `Vue`. Сюда входят:

- **[DevTools](https://devtools.vuejs.org/)** - инструменты разработчика в браузере
- **[Vue CLI](https://cli.vuejs.org/)** - утилита командной строки
- **[Vue Loader](https://vue-loader.vuejs.org/)** - лоадер `vue` для `webpack`
- **[Vue Router](https://router.vuejs.org/)** - роутинг страниц на `vue`
- **[Vuex](https://vuex.vuejs.org/)** - глобальное хранилище данных на фронте
- **[Vue SSR](https://ssr.vuejs.org/)** - отрисовка компонентов на сервере

Данные библиотеки поддерживаются разработчиками самого `Vue`, поэтому эта система
зависимостей обладает очень высоким уровнем совместимости. <br>
Помимо основных библиотек во `Vue` можно использовать и огромное количество сторонних
сервисов для всевозможного расширения функционала фреймворка - плагины, директивы, а также
библиотеки компонентов
***

### 4. Библиотеки компонентов

Для разработки кастомных стилей `Vue` предлагает массу удобств - от `scoped`-стилей до
использования `sass` в однофайловых компонентах. <br>
Однако не всегда требуется кастомизировать стилевое оформление сайта каким-то конкретным
образом. Для разработки на `Vue` существует масса библиотек компонентов с определенными
стилями, что позволяет быстро создавать интерфейсы самых разных уровней сложности. <br>
Вот некоторые из них:

1. **[BootstrapVue](https://bootstrap-vue.org/)**
2. **[Element UI](https://element.eleme.io/#/en-US)**
3. **[Vuetify](https://vuetifyjs.com/en/)**
4. **[Vue Material](https://www.creative-tim.com/vuematerial/)**
5. **[VueTailwind](https://www.vue-tailwind.com/)**
6. etc

Компоненты в данных библиотеках во многом совпадают - элементы форм, каточек, каруселей,
кнопок, уведомлений и так далее. Для своего сайты Вы можете выбрать любой понравившийся
дизайн.

В компаниях занимающихся разработкой своих сайтов чаще всего свое стилевое наполнение
(особенно, если сайт многостраничный). Это значит, что в проекте используется своя
библиотека компонентов.

Библиотеки компонентов принято называть с постфиксом `ui` (`user interface`). <br>
В СЭД "Практика", например, такая библиотека имеет имя `sed-ui`. <br>
Каждый компонент тоже должен называться так, чтобы можно было понять, что он относится к
общей библиотеке. Например, `SedSelect.vue`, `SedInput.vue`, `SedTextarea.vue` и т.д.

Разработку кастомной библиотеки компонентов стоит вести с особой внимательностью к
деталям, так как данные компоненты будут использоваться повсеместно.

Вот некоторые принципы, используемые при разработке кастомной библиотеки компонентов:

1. Компоненты должны иметь простой интерфейс. <br>
   Компонент - это абстракция в коде. Абстракция хороша только тогда, когда при ее
   использовании Вам не приходится тратить много времени на изучение ее интерфейса
   (входных параметров). Поэтому в компоненты нужно стараться передавать минимум данных
   (но достаточный для работы объём). Если в Вашем компоненте слишком много входных
   данных, возможно, стоит задуматься о его разбиении на несколько компонентов поменьше.
2. Компоненты должны отдавать родителю минимум данных. <br>
   Аналогично и с данными, которые компонент передает родителю. При большом их количестве
   и объеме пользователю Вашей библиотеки (другому разработчику) будет сложно пользоваться
   данным компонентом, а значит он намного быстрее станет частью `legacy` Вашего
   проекта. <br>
   Если из дочернего компонента нужно передать информацию о том, какой элемент массива
   нужно удалить, не нужно передавать весь элемент (объект с данными), достаточно передать
   только его индекс (одно число).
3. Компоненты должны быть расширяемы. <br>
   При первоначальном создании библиотеки невозможно предусмотреть все возможные варианты
   видоизменения компонентов в будущем, поэтому необходимо реализовывать логику работы
   компонента так, чтобы впоследствии эту логику можно было расширить. Например, если вы
   хотите передать какие-то данные, то это можно (но не нужно) сделать так:

```
const data = [ dataOne, dataTwo, ...moreData ];
```

Проблема здесь в том, что при необходимости добавления самостоятельного ключа `dataThree`
логика работы компонента будет сломана.

4. В компонентах должна быть продумана система кастомизации конкретных участков. <br>
   Зачастую некоторые блоки компонентов могут иметь разные варианты содержания. Хорошим
   подходом будет тот, где Вы описываете в этом место некое дефолтное отображение, а также
   оставляете возможность выводить там что-то уникальное (см. `slots` ниже)
5. Входные данные должны валидироваться. <br>
   Так как наша основная задача - сделать удобный для использования компонент, необходимо
   предусмотреть внутренние проверки входных данных (пропов) внутри. Для этого можно
   определить типы данных каждого пропа (`type`), дефолтное значение (`default`), а также
   функцию-валидатор для более детальной проверки каждого аргумента (`validator`)
6. Стили компонента должны гибко настраиваться и легко переопределяться снаружи. <br>
   Идеальный вариант создания компонентов - создание их совместно с отделом дизайнеров.
   Дизайнеры могут определить несколько основных типов стилевого оформления, а разработчик
   на их основе создаст гибкую систему настройки компонента. Например, в проекте могут
   существовать кнопки разных размеров (`xs`, `s`, `sm`, `m`, `xl`) и разных
   тем (`primary`, `common`, `secondary`, `dafault` etc). <br>
   Помимо этого компонент должен оставлять возможность переопределения базовых стилей.
7. Компонент должен быть структурной единицей, которую можно поместить в любое место
   сайта. <br>
   Данный пункт связан с размещением компонента в массиве других элементов на странице.
   Неуместно для компонента использовать `position: fixed;`, а также `margin-left: 20px;`,
   так как данные стили почти всегда придется переопределять снаружи. Общее
   позиционирование компонента - ответственность компонента-родителя.

***

### 5. Слоты

> Slots - это API распределения контента

Слоты позволяют определять в компонентах участки шаблонов, которые будут наполняться
снаружи (то есть определяться в компоненте-родителе).

Самый простой вариант использования слотов - проброс контента внутрь дочернего компонента:

В компоненте-родителе:

```
<CommonButton @save="onSave">
    Сохранить
</CommonButton>
```

В компоненте-ребенке:

```
<button
    class="btn btn-danger"
    @click="$emit('save')"
>
    <slot></slot>
</button>
```

В данном случае при отрисовке компонента-ребенка блок `<slot></slot>` будет заменен
на `Сохранить`. <br>
Здесь же можно определить дефолтное состояние слота, для этого нужно добавить что-то в
блок `<slot></slot>`:

```
<button
    class="btn btn-danger"
    @click="$emit('save')"
>
    <slot>Подтвердить</slot>
</button>
```

Теперь в случае, если в компонент не будет передан слот, в кнопке выведется
текст `Подтвердить`

#### Именованные слоты [самостоятельное изучение]

По умолчанию можно добавить один безымянный слот, он (под капотом) имеет имя `default`.
Однако можно определить несколько слотов, задав им определенные имена с помощью
директивы `v-slot`:

В компоненте-родителе:

```
<ModalContainer>
    <template v-slot:header> - header - имя слота
        <h2>{{ headerText }}</h2>
    </template>
    
    // все, что передается в слоты без имени автоматически становится
    // наполнением дефолтного слота (с именем `default`)
    <p>Какой-то текст</p>
    
    // Можно так же и полно:
    <template v-slot:default>
        <p>Какой-то текст</p>
    </template>
    
    <template v-slot:footer>
        <p>Ссылка на Гитхаб</p>
    </template>
</ModalContainer>
```

В компоненте-ребенке:

```
<div>
    <header>
        <slot name="header"></slot> - описываем именованные слоты
    </header>
    <main>
        <slot></slot> - описываем "безымянный" слот
    </main>
    <footer>
        <slot name="footer"></slot>
    </footer>
</div>
```

Здесь важно понимать, что у слотов самая обычная область видимости. Это значит, что в
слоте без дополнительных манипуляций можно получить доступ только к тем ключам, которые
присутствуют в текущем компоненте.

Например, если в компоненте-родителе попытаться "достучаться" до ключа из
компонента-ребенка:

```
<CommonButton @save="onSave">
    {{ saveText }} - ключ `saveText` есть только в компоненте `CommonButton`
</CommonButton>
```

Мы неизбежно получим ошибку, так как в текущем компоненте данного ключа попросту нет. <br>
Тем не менее передать данные в слот из дочернего компонента все же можно. Для этого в
компоненте-ребенке мы должны передать требуемые данные в слот через директиву `v-bind`, а
в компоненте-родителе эти данные получить в директиве `v-slot`:

В компоненте-родителе:

```
<CommonButton @save="onSave">
    <template v-slot:default="currentProps"> - получаем данные в виде currentProps
        {{ currentProps.user.name }}
    </template>
</CommonButton>
```

В компоненте-ребенке:

```
<button
    class="btn btn-danger"
    @click="$emit('save')"
>
    <slot v-bind:user="user"> - передаем данные в слот в родительском компоненте
        {{ user.name }}
    </slot>
</button>
```

В примере мы определили данные как `currentProps` - этот ключ можно именовать как удобно

Мы разобрали, как можно передать данные в именованный слот (в примере
вместо `v-slot:default` может быть любой другой именованный слот). Для случаев с
единственным дефолтным слотом есть короткая запись:

```
<template v-slot="currentProps">
    {{ currentProps.user.name }}
</template>
```

Учитывая, что значение `v-slot` может принимать любое допустимое выражение `JavaScript`,
данный шаблон можно упростить еще, деструктурировав `currentProps`:

```
<template v-slot="{ user }">
    {{ user.name }}
</template>
```

#### Короткая запись именованных слотов [самостоятельное изучение]

Короткая запись есть у таких директив, как `v-bind` и `v-on`. У директивы `v-slot` тоже
есть своя - с символом `#`:

```
<ModalContainer>
    <template #header> - короткая запись именованного слота (аналог `v-slot:header`)
        <h2>{{ headerText }}</h2>
    </template>
    
    <p>Какой-то текст</p>
    
    <template #footer>
        <p>Ссылка на Гитхаб</p>
    </template>
</ModalContainer>
```

#### Динамические слоты [самостоятельное изучение]

Для случаев, когда имя слота должно меняться динамически, предусмотрен специальный
синтаксис (в стиле чистого `JS`):

```
<template v-slot:[slotName]="currentProps"> - передаем имя слота как `slotName`
    {{ currentProps.user.name }}
</template>
```

***

### 6. Transitions in Vue [самостоятельное изучение]

Настройка анимации - зачастую непростая задача, требующая приличного объема знаний и
опыта. Современный мир разработки предлагает множество способов настроить анимацию
элементов в своем проекте. Это и кастомные решения на чистом `css`, и анимации с помощью
нативного `JS` или `JQuery`, и специальные библиотеки. Вот некоторые из них:

- **[Velocity.js](http://velocityjs.org/)**
- **[Animate CSS](https://animate.style/)**
- **[Vue2-animate](https://github.com/asika32764/vue2-animate)** - `Animate CSS` in `Vue`
- **[Material Components](https://github.com/material-components/material-components-web)**
- etc

`Vue` "из коробки" предоставляет возможность настраивать анимации разного уровня
сложности. Вот некоторые из возможностей:

- Анимация одиночного элемента/компонента
- Переходы при первичной отрисовке
- Переходы между компонентами
- Анимация списков

Общая логика работы анимаций во `Vue` следующая:

1. Оборачиваем элемент в тег `transition`, устанавливаем атрибут `name`:

```
<transition name="fade">
    <p v-if="show">Анимация</p>
</transition>
```

2. В стилях добавляем соответствующие классы, начинающиеся на определенный в
   теге `transition` атрибут `name` и заканчивающиеся на структурные подклассы:

```
.fade-enter-active, .fade-leave-active {
    transition: opacity .5s;
}

.fade-enter, .fade-leave-to {
    opacity: 0;
}
```

Вот некоторые классы, которые можно использовать для анимации:

- `v-enter` - начало анимации появления элемента;
- `v-enter-active` - анимация появления элемента активна;
- `v-enter-to` - анимация появления элемента завершается;
- `v-leave` - начало анимации исчезновения элемента;
- `v-leave-active` - анимация исчезновения элемента активна;
- `v-leave-to` - анимация исчезновения элемента завершается.

В них `v` необходимо заменить на `name` - например, `v-fade...`

Более подробно с анимацией на `Vue` можно
познакомиться **[здесь](https://ru.vuejs.org/v2/guide/transitions.html)**