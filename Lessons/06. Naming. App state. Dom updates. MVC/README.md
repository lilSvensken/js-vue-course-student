### 1. Принципы именования сущностей в программировании

Грамотное именование сущностей в коде - сложная и крайне важная задача. Именование
напрямую влияет на качество кода.

Рассмотрим два блока кода.

- С неграмотным именованием переменных:

```
let str = '';

const func = (data) => {
    const el = document.createElement('span');
    const data1 = data.rownum;
    const data2 = data.user_name;
    const data3 = data.exec_date;
    const data4 = data.exec_change_date;
    let str = data1 + '. ' + data2 + ' - срок: ' + data3;
    if (data3) {
        str += ' - изменен: ' + data4;
    }
    str += '<br/>';
    el.innerHTML = str;

    return el;
}
```

- С грамотным именованием переменных:

```
/*
 * Создаем строку для конкретного изменения исполнителя
 */
 
let resultString = '';

const getHistoryItem = (historyItemData) => {
    const rootSpan = document.createElement('span');
    const itemNumber = historyItemData.rownum;
    const userName = historyItemData.user_name;
    const executionDate = historyItemData.exec_date;
    const changeDate = historyItemData.exec_change_date;
    let resultString = itemNumber + '. ' + userName + ' - срок: ' + executionDate;
    if (changeDate) {
        resultString += ' - изменен: ' + changeDate;
    }
    resultString += '<br/>';
    rootSpan.innerHTML = resultString;

    return rootSpan;
}
```

В первом случае для понимания задачи функции нам необходимо изучить ее целиком. Во втором
же случае мы имеем не только "говорящее" имя функции, но и "самодокументируемый" код
внутри, в котором намного проще разобраться, чем в коде в первом примере.

Для именования сущностей могут быть использованы следующие подходы:

- Сокращения

Сокращения уместны в редких случаях. Например, общепринятые сокращения: `x`, `y`, `z` для
координат, `num` для чисел, `e` для `error` и так далее. <br>
Однако сокращения `ch`, `ev`, `d` и др. неуместны, так как понять по ним, что лежит в
конкретной переменной, невозможно.

- Именование объектов (без привязки к синтаксису `JS` (не только `{}`))

Для именования переменных-существительных используются (барабанная дробь...)
существительные, описывающие сам элемент, например:

```
const responseData;     // данные ответа
const currentDate;      // текущая дата
const userId;           // идентификатор пользователя
const documentSize;     // размер документа
const amountOfRows;     // количество рядов
```

В названии должна присутствовать необходимая и достаточная для понимания информация.

- Именование функций

Функция совершает какое-то действие, следовательно, в ее имени должно быть заложено
какое-то действие (глагол). Например:

```
const reorderDigits = () => ({});       // поменять порядок цифр
const getUserData = () => ({});         // получить данные о пользователе
const removeBlock = () => ({});         // удалить блок
const setErrandInfo = () => ({});       // установить информацию о поручении 
```

- Именование предикатов

Если в переменной лежит (должно лежать) булево значение - перед нами предикат, отвечающий
на вопрос `да или нет?`. В именах таких переменных должен быть заложен вопрос:

```
const isLoading;        // идет ли загрузка
const areWindowsOpen;   // открыты ли окна
const isNumberEven;     // четное ли число
const isStateEmpty;     // пусто ли состояние
```

***

### 2. Состояние приложения

В простых учебных заданиях достаточно описать элементы на странице и навестить на события
обработчики, которые просто будут обновлять `DOM`, однако в реальных проектах количество
элементов на странице, а также событий и обработчиков огромно. Такой подход неминуемо
приведет к тому, что в коде будет нельзя разобраться и что-либо исправить/доработать.

Разберем пример с кнопкой из `Lesson 05. Task 1`. <br>
В данном случае мы обновляли `DOM` в обработчике, находя текущее число в самой кнопке:

```
const countText = 'Количество нажатий: ';
const counter = document.querySelector('.main');
const button = document.createElement('button');
button.textContent = countText + '0';

button.addEventListener('click', (event) => {
    const currentCount = event.target.textContent.split(': ')[1]; // Берем текст из кнопки
    const newCount = Number(currentCount) + 1;
    event.target.textContent = countText + newCount;
});

counter.append(button);
```

При таком подходе мы рискуем получить довольно "хрупкий код", в котором не будет
единственного источника "правды". Данная кнопка может быть не одна, в ней может меняться
текст. И если при работе с приложением опираться на конкретные `DOM`-элементы, очень скоро
проект запутается донельзя, так как вся структурная информация равномерно распределена по
всему коду (а это могут быть сотни и тысячи строк кода). Так что же делать?

Проблему поможет решить грамотное выделение общего состояния приложения:

```
const setCounter = () => {
    let number = 0;                                     // состояние приложения

    const countText = 'Количество нажатий: ';
    const counter = document.querySelector('.main');
    const button = document.createElement('button');
    button.textContent = `${countText} ${number}`;      // использование состояния

    button.addEventListener('click', () => {
        number += 1;                                    // обновление состояния
        button.textContent = `${countText} ${number}`;  // использование состояния
    });

    counter.append(button);
};

setCounter();
```

В данном случае состоянием приложения является переменная `number`, которую мы обновляем в
обработчике.<br>
Здесь мы не завязываемся на конкретную реализацию (на саму кнопку). То, какой текст
находится в кнопке, нам неважно. Теперь в приложении есть абсолютный ориентир (наше
состояние), на который опирается вся остальная реализация.

***

### 3. Конечные автоматы

"Выделить состояние" - звучит просто... но только звучит. Что можно выделить в состояние,
а что выделять нежелательно?

Одним из наиболее продвинутых способов реализации архитектуры приложения является <br>
**автоматное программирование**.<br>
Его смысл заключается в том, чтобы определить в приложении базовые "автоматы" - состояния
приложения, опираясь на которые можно реализовать всю остальную логику. В таком случае
архитектурная основа приложения будет максимально проста, но при этом максимально
информативна.

Рассмотрим пример с формой отправки сообщения в чате и выделим конечные автоматы.<br>
Наше приложение состоит из поля ввода сообщения и кнопки "Отправить". Кнопка может быть
заблокирована, поле ввода может подсвечиваться красным, если что-то пошло не так, под
полем ввода может выводиться сообщение об ошибке.

Таким образом, наше состояние может выглядеть следующим образом:

```
const state = {
    sendMessage: {
        isMessageValid: true,
        isErrorMessageActive: false,
        isMessageSending: false,
        // что-то еще
    }
}
```

В данном случае мы имеем множество ключей, отвечающих за отдельные элементы на странице.
При их большом количестве работать с состоянием будет очень тяжело.

Выделим в нашем приложении процессы, описывающие основную логику работы:

```
const state = {
    sendMessage: {
        currentState: 'sendFailed',
        isMessageValid: false,
        errors: ['слишком длинное сообщение'],
    }
}
```

Мы выделили "состояния" приложения на каждый момент времени. Теперь можно переключаться
между ними в коде и отрисовывать `ui` на основе того, какое состояние приложение имеет в
конкретный момент времени:

- `typing` - пользователь набирает сообщение. Кнопка `Отправить` разблокирована, поле
  подсвечивается синим цветом;
- `sending` - сообщение отправляется. Кнопка и поле ввода заблокированы;
- `sendFailed` - сообщение не отправилось. Все разблокировано, поле ввода подсвечивается
  красным цветом, под ним появляется текст ошибки;
- `sendSuccesed` - сообщение успешно отправлено. Поле ввода очистилось, все
  разблокировано, ошибки не отображаются, поле никак не подсвечивается.

Теперь при перерисовке мы будем отталкиваться не от того, какой внешний вид имеют элементы
в данный момент, а от того, в каком состоянии находится наше приложение в целом. То есть
будем опираться не на следствие, а на причину, повысив таким образом читаемость и
расширяемость нашего кода.

***

### 4. Обновление DOM при обновлении состояния

После грамотного выделения состояния в приложении возникает логичный вопрос, а как же
тогда обновлять `DOM`. В какой момент, где и как это делать?

Разберем пример все с тем же счетчиком.<br>
Функция рендеринга приложения может работать следующим образом:

```
// Определяем функцию, которая будет на основе текущего состояния "перерисовывать" страницу
const render = (state) => {
    const countText = 'Количество нажатий: ';
    const button = document.querySelector('button');

    // Обновляем `DOM`-элементы
    button.textContent = `${countText} ${state.number}`;
};

const setCounter = () => {
    // Состояние приложения
    const state = {
        number: 0,
    };

    const counter = document.querySelector('.main');
    const button = document.createElement('button');
    button.classList.add('btn', 'btn-warning');
    counter.append(button);

    // Навешиваем на элементы интерфейса обработчики событий, которые будут обновлять
    // состояние приложения и впоследствии вызывать нашу функцию `render`
    button.addEventListener('click', () => {
        state.number += 1;
        
        // вызываем каждый раз при клике по кнопке
        render(state);
    });

    // вызываем один раз для первичного рендера приложения
    render(state);
};
```

Здесь мы неизбежно получаем более низкую производительность за счет того, что
функция `render` внутри каждый раз ищет на странице элементы. От этого можно избавиться,
определив их (элементы) один раз (и положив, например, в состояние), после чего можно
будет обращаться к ним без постоянного поиска. Однако важно понимать, что
**[оптимизация](https://optimization.guide/)** не всегда уместна.

***

### 5. MVC

**MVC** (`Model View Controller`) - концепция разделения приложения на три слоя - Модель,
Представление, Мозги приложения

![MVC](http://abap4.ru/wp-content/uploads/2020/08/mvc.png)

- `Model` - состояние приложения. В нем описаны все фундаментальные данные приложения -
  например, список чатов и сообщений в них;
- `View` - слой, отвечающий за внешний вид приложения (`ui`). Здесь обрабатываются
  действия пользователя и происходит обновление `DOM`-элементов при изменении основного
  состояния (слоя `Model`)
- `Controller` - Мозги приложения. Здесь в ответ на действия пользователя выполняются
  какие-либо действия (запросы на сервер, проверки данных, вычисления и т.д.), после чего
  обновляется глобальное состояние приложения (слой `Model`). Данный слой отвечает не за
  работу с сервером как таковую, а за общую обработку действий пользователя. Отправка
  запросов на сервер может отсутствовать в приложении, при этом оно все еще может быть
  реализовано на основе концепции `MVC`.

**Важно** <br>
Концепция `MVC` определяет базовые слои устройства приложения, но не саму реализацию. В
каждом отдельном случае разные слои могут быть реализованы по-разному. <br>
Для более глубокого понимания рассмотрим тот же пример с кнопкой (см.
директорию `./MVC example`).<br>
Здесь основной структурной единицей является состояние в функции `app`:

```
const state = {
    number: 0,
};
```

В данном объекте мы описали все основные данные приложения. <br>
Объект `state` - реализация слоя `Model`.

Здесь важно отметить, что выделение состояния приложения решает проблему конфликта разных
источников данных. Так, если на текст кнопки влияет несколько мест в коде, нам будет
крайне сложно найти баг и грамотно устранить его. Выделив состояние и исключив любые
манипуляции с данными в обход этого состояния, мы соблюли **принцип единственного
источника правды**. Объект `state` - тот самый источник.

На элементы на странице мы навесили обработчики, которые обновляют наше состояние:

```
const button = document.querySelector('button');
button.addEventListener('click', () => {
    state.number += 1;
});
```

Это слой `Controller`. Здесь производятся внутренние операции нашего приложения. Например,
производятся запросы к серверу.

В пункте **3. "Обновление DOM при обновлении состояния"** мы создавали функцию `render`,
которую необходимо вызывать каждый раз при обработке каких-либо событий. Проблема здесь в
том, что таких событий может быть много. Это приведет к многократному дублированию вызова
функции `render`, а также к очень сложной логике внутри самой функции (в ней придется
описывать множество вариантов для каждого элемента отдельно (для поля ввода, кнопки и
любых других сущностей)).<br>
Данную сложность устраняют так называемые "наблюдатели" - методы в коде, которые
отслеживают изменения каких-либо частей состояния и в ответ на эти изменения выполняют
какой-то код. В нашем случае "наблюдателем" является функция `watchState`:

```
// Отслеживаем изменения состояния
watchState(state);
```

Заметьте, что функция выделена в отдельный модуль, что позволяет грамотно разделить логику
приложения.<br> Внутри она работает через
библиотеку **[melanke-watchjs](https://github.com/melanke/Watch.JS/)**:

```
const watchState = (state) => {
    const countText = 'Количество нажатий: ';
    const button = document.querySelector('button');

    // Отслеживаем изменение ключа "number" в состоянии
    watch(state, 'number', () => {
        button.textContent = `${countText} ${state.number}`;
    });
};
```

Функция "прослушивает" отдельные ключи состояния и на основе этого же состояния мутирует
(перерисовывает) нашу страницу (`DOM`-дерево).

Представленный пример очень прост и, конечно, для реализации обычного счетчика избыточно
использовать `MVC` - слишком много нагромождений логики ради решения микрозадачи. Однако
данный пример помогает без глубокого погружения в сложную бизнес-логику познакомиться с
важной концепцией. В большом приложении использование концепции `MVC` позволяет
значительно снизить когнитивную нагрузку при написании, рефакторинге и расширении кода.
Более того, искать и исправлять ошибки тоже становится значительно проще.

#### Рендер-функции во фреймфорках

В современных фреймворках (например, `Vue` и `React`) не нужно столько времени уделять
рендерингу `DOM`-дерева, так как там "из коробки" работает реактивность, благодаря которой
фреймворк автоматически вызывает функцию рендеринга при каждом изменении состояния. Тем не
менее важно понимать, что внутри эта реактивность реализована на самых
обычных `JavaScript`-подходах - никакой магии.