### 1. Декларативное и императивное программирование

**Императивное программирование** — это пошаговое описание последовательности выполнения
задачи.

**Декларативное программирование** — это логическое описание процесса выполнения задачи.

> Ничего не понятно, но очень интересно -_-

На самом деле перед нами довольно простые концепции написания кода, в которых мы сейчас
разберемся

Разберем пример кода в императивном (от лат. `impero` — "повелеваю") стиле:

```
// Имеем массив чисел и метод для проверки на четность
const array = [ 1, 2, 3, 4, 5, 6 ];
const isEven = (x) => x % 2 === 0;

const evenNumbers = [];

// Пошагово проходим по массиву и если условие выполняется, добавляем значение в новый массив
// Код отвечает на вопрос "Как пошагово сделать задачу?"
for (let i = 0; i < array.length; i++) {
    if (isEven(array[i])) {
        evenNumbers.push(array[i]);
    }
}
```

Пример код в декларативном (от лат. `declarare` — "заявлять, изъявлять, выражать") стиле

```
const array = [ 1, 2, 3, 4, 5, 6 ];
const isEven = (x) => x % 2 === 0;

// Наша задача - профильтровать массив, поэтому используем метод `filter`
// Код отвечает на вопрос "Что нужно сделать в задаче?"
const evenNumbers = array.filter(isEven);
```

Итак, императивный метод "по-глупому" проходит по массиву и отбирает из него нужные
элементы, в то время как декларативный "по-умному" делает именно то, что нам нужно -
фильтрует массив удобным методом `filter`.

С первого взгляда может показаться, что императивные методы не нужны, раз есть такие
удобные понятные человеку декларативные способы решения тех же задач. Но здесь нужно
вспомнить, что компьютер - максимально глупое создание. Он делает ровно то, что мы ему
скажем и никаких "декларативных", умных инструкций он не понимает. Кто-то должен объяснить
ему, что делает метод `.filter`. А внутри он делает как раз-таки императивный обход
массива с отбором нужных элементов.

Таким образом, **декларативные методы - это абстракции над императивными реализациями**.
Данное деление призвано дать разработчикам более глубокое понимание работы кода и
выделения различных сущностей в абстракции.

Примеры декларативных языков: `SQL`, `HTML`, `CSS`. Примеры императивных языков: `C`
, `C++`, `Java`.

***

### 2. Функциональное программирование в `JS`

**Функциональное программирование** - программирование, в котором основным строительным
блоком приложения является **функция**. Это также наиболее распространенный способ
создания проектов на `JS`. <br>
В `JS` функции являются **объектами первого рода**, что позволяет гибко выстраивать
цепочку вызовов функций, создавая хорошо расширяемые программы. <br>

Основная задача функционального программирования - сделать код понятнее. <br>
Рассмотрим некоторые концепции **ФП**

#### 1. Композиция

**Композиция функций** — это передача результата выполнения одной функции аргументом в
другую функцию. Говоря языком алгебры: задаются две функции `f` и `g`, их композиция имеет
следующий вид: `f(g(x))`.

Пример реализации функции композицией:

```
const compose = (f, g) => {
    return (x) => {
        return f(g(x));
    };
};
```

Это базовый вариант реализации. Обратите внимание: функции в аргументах будут выполняться
справа налево. То есть сначала выполняется функция, расположенная справа, и ее результат
передается в функцию слева от нее.

На самом деле при написании кода мы часто используем композицию (сознательно или же
случайно). Ниже пример кода, который переворачивает строку, а затем переводит ее в верхний
регистр.

```
const reverseAndUpper = (str) => {
    const reversed = reverse(str);
    return upperCase(reversed);
}
```

Мы могли бы получить такой же результат, написав код:

```
const reverseAndUpper = (str) => upperCase(reverse(str));
```

#### 2. Каррирование

**Каррирование** – это трансформация функций таким образом, чтобы они принимали аргументы
не едино (`f(a, b, c)`), а раздельно (`f(a)(b)(c)`). Каррирование не вызывает функцию, оно
просто трансформирует её.

Пример реализации функции каррирования для функций 2-х аргументов:

```
const curry = (f) => {
    return (a) => {
        return (b) => {
            return f(a, b);
        };
    };
}
```

Использование

```
const sum = (a, b) => {
    return a + b;
}

const carriedSum = curry(sum);

console.log(carriedSum(1)(2));    // 3
```

По сути каррирование - способ реализовать "замыкание" (см. первое занятие)

#### 3. Чистые функции

**Чистые функции** - строительные блоки в функциональном программировании. Их ценят за
простоту и тестируемость.

Чтобы считаться «чистой», функция должна удовлетворять двум условиям:

— Быть детерминированной - всегда возвращать один и тот же результат при вызове с одним и
тем же набором аргументов:

```
const sqr = (x) => x * x;
```

Функция нахождения квадрата переданного числа детерминирована, то есть всегда возвращает
одинаковое значение для одинаковых входных данных

```
const getRandom = () => Math.random();
```

Функция `getRandom` детерминированной не является, так как при одних и тех же аргументах (
в данном случае их нет) возвращает разные результаты

— Не обладать побочными эффектами

**Побочный эффект функции** - возможность в процессе выполнения своих вычислений читать и
модифицировать значения глобальных переменных или аргументов, осуществлять операции
ввода-вывода, реагировать на исключительные ситуации, вызывать их обработчики.

Примеры побочных эффектов:

1. Мутация входных параметров
2. Вывод в консоль (console.log)
3. HTTP вызовы (AJAX/fetch)
4. Изменения в файловой системе
5. Запросы DOM

Пример "нечистой функции":

```
const impureDouble = (x) => {
    console.log('doubling', x);
    return x * 2;
};
const result = impureDouble(4);
console.log({ result });
```

#### 4. Пайплайны

Объектные типы в `JS` обладают встроенными методами, к которым можно обращаться через
точку. Например: <br>

```
const nameLength = 'Alex'.length;
```

Возможность выстраивать функции через так называемый `pipeline` (с англ. - трубопровод)
позволяет обрабатывать данные удобно не только с точки зрения создания кода, но и с точки
зрения его чтения.

Классический пример пайплайна - агрегация данных.<br>
Допустим, у нас есть массив `cars`:

```
cars = [
    { name: 'Tesla Model 3', age: 2, sold: false },
    { name: 'BMW M3', age: 4, sold: true },
    { name: 'Audi RS6 Avant', age: 7, sold: false },
    { name: 'Mercedes GLA', age: 4, sold: false },
    { name: 'Volga', age: 25, sold: true },
]
```

Наша задача получить строку, где через запятую будут перечислены все непроданные
машины. <br>
Для решения задачи воспользуемся метода "высшего порядка" `filter` и `map`. Эти методы
вызываются на массиве и возвращают другой массив, поэтому мы можем соединять операции в
"пайплайны":

Здесь же для удобства применим "деструктуризацию" объектов - способ в краткой и удобной
форме получить данные из объекта. Рассмотрим пример:

```
const user = {
    name: 'Dan',
    surname: 'Abramov',
    age: 100
};
const { name, age } = user;     // "Создай переменные name и age со значениями из объекта "user""
console.log(name);              // 'Dan'
console.log(age);               // 100
```

Итак, пример "пайплайна":

```
const str = cars
    .filter(({ sold }) => !sold)    // Профильтровали массив
    .map(({ name }) => name)        // Преобразовали массив
    .join(', ');                    // Объединили данные в строку

console.log(str);  // "Tesla Model 3, Audi RS6 Avant, Mercedes GLA"
```

Обратите внимание на то, как удобно, что кто-то выделил императивную логику фильтрации,
маппинга и объединения в высокоуровневые декларативные абстракции `filter`, `map` и `join`

#### А можно пример ФП?

Помимо пайплайна функции могут комбинироваться и более сложным способом, например,
рассмотрим структуру программы, работающей с геометрическими фигурами:

```
const getPointesFromImage = (image) => {
    ...получаем точки из картинки...
    
    return points;
}

const transformPoints = (points) => {
    ...работаем с точками...
    
    return transformedPoints;
};

const filterPrimitivesByLength = (primitives) => {
    ...работаем с примитивами...
    
    return filteredPrimitives;
};

const getPrimitivesFromPoints = (points, helpFunction) => {
    const filteredData = helpFunction(somePrimitives);
    ...получаем геометрические примитивы...
    
    return primitives;
};

const getFiguresFromPrimitives = (points) => {
    ...получаем геометрические примитивы...
    
    return figures;
};

const getGraphData = (figures) => {
    ...получаем данные для графика на основе полученных фигур...
    
    return graphData;
}

const getReport = (data) => {
    ...получаем отчет на основе данных...
    
    return report;
}

const app = (image) => {
    const points = getPointesFromImage(image);
    const transformedPoints = transformPoints(points);
    const primitives = getPrimitivesFromPoints(transformedPoints, filterPrimitivesByLength);
    const figures = getFiguresFromPrimitives(primitives);
    const graphData = getGraphData(figures);
    const report = getReport(graphData);
    return report;
}

export default app;
```

Здесь наглядно показано, в чем смысл `ФП`, а именно в выделении в коде грамотных
абстракций (функций).<br>
Таким образом, каждый `модуль` отвечает за небольшую часть приложения (за определенный его
уровень). Каждый уровень независим и работает сам по себе, ничего не зная о том, как
данные обрабатываются на других уровнях. <br>
Например, модуль `app` отвечает только за то, чтобы из картинки сделать некий отчет.
Откуда пришла эта картинка, что с ней делалось прежде, а также какова будущая судьба
итогового отчета, функцию `app` не интересует, это не ее зона ответственности.

***

### 3. Объектно-ориентированное программирование в `JS`

В `JS` **нет классов**, однако реализовать приложение в ООП-стиле все же можно.<br>
Разберем пример с использованием функций. Создадим сущность `student`:

#### 1. Объекты и функции без инкапсуляции методов

```
// Функция-конструктор
const setStudent = (name, age, institute) => {
    return { name, age, institute };
};

// Геттеры
const getName = (student) => student.name;
const getAge = (student) => student.age;
const getInstitute = (student) => student.institute;
```

Использовать данную сущность можно следующим образом:

```
const student = setStudent('Dmitro', 20, 'ITIS');
console.log(getName(student));   // 'Dmitro'
```

#### 2. Объекты и функции с инкапсуляцией методов

Объединим весь функционал в одну функцию:

```
export const setStudent = (name, age, institute) => {
    return {
        name,
        age,
        institute,
        getName() { // Важно использовать именно обычную функцию, у стрелочных нет своего контекста!
            return this.name;
        },
        getAge() {
            return this.age;
        },
        getInstitute() {
            return this.institute;
        },
    };
};
```

В другом файле:

```
const student = setStudent('Dmitro', 20, 'ITIS');
console.log(student.getName());   // 'Dmitro'
```

#### 3. Генерация через функцию-конструктор

```
// Определим геттеры за пределами конструктора
function getName() {
    return this.name;
};

function getAge() {
    return this.age;
};

// Конструктры (как и классы в целом) принято именовать с большой буквы
function Student(name, age, institute) {
    this.name = name;
    this.age = age;
    this.institute = institute;
    this.getName = getName;
    this.getAge = getAge;
};
```

Используем так:

```
const student = new Student('Dmitro', 20, 'ITIS');
console.log(student.getAge());   // 20
```

#### Прототипы

Объектные типы имеют прототипы - объекты, на которые есть ссылки у других объектов. <br>
Тема прототипного наследования в `JS` очень объемна и сложна (и выходит за пределы этого
курса). Вы можете самостоятельно изучить
ее **[здесь](https://learn.javascript.ru/prototype-inheritance)**

#### 4. "Классы"

Синтаксис реализации классов следующий:

```
class Student {
    // описываем функцию-конструктор, которая определит
    // внутреннее состояние экземпляра класса
    constructor(name, age, institute) {
        this.name = name;
        this.age = age;
        this.institute = institute;
        this.projects = [];
    }
    // Описываем методы
    getName() {
        return this.name;
    }
    getAge() {
        return this.age;
    }
};
```

Используем аналогично:

```
// Экземпляр класса создаем с помощью ключевого слова `new`
const student = new Student('Dmitro', 20, 'ITIS');
console.log(student.getAge());   // 20
```

Метод `constructor` вызывается автоматически при обращении к классу через `new` -
происходит создание экземпляра.

#### Наследование классов

Для создания наследственной связи между классами используется ключевое слово `extends`

```
class Actor {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    getIsKeanu() {
        return this.name === 'Keanu';
    }
    getAge() {
        return this.age;
    }
};

class HollywoodActor extends Actor {
    constructor(name, age, movies) {
        // super - ключевое слово, вызывающее родительский конструктор.
        // В данном случае мы наследуем аргументы
        super(name, age);
        this.movies = movies;
    }
    getMovies() {
        return this.movies;
    }
}

const currentActor = new HollywoodActor('Keanu', 57, [ *some movies* ]);
currentActor.getIsKeanu();  // true
currentActor.getAge();      // 57
```

Выше было сказано, что в `JS` нет классов. Тогда что же перед нами?

```
console.log(typeof Student); // 'function'
```

Да, перед нами все еще функция, покрытая для нашего с вами удобства "синтаксическим
сахаром" языка.

#### Статические свойства и методы классов

Используются для реализации методов, принадлежащих классу (но не конкретным вхождениям
данного класса). Это, например, могут быть методы для каких-либо внутренних манипуляций

```
class User {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    static sortByAge(userOne, userTwo) {
        return userOne.age - userTwo.age;
    }
}
```

Здесь `sortByAge` - статический метод.<br>
Использовать его можно следующим образом:

```
let users = [
    new User("Sergey", 42),
    new User("Dmitro", 24),
    new User("Liya", 32)
];

users.sort(User.sortByAge);
```

Пользователи отсортируются "на месте".

Статические свойства определяются похожим образом:

```
class User {
    static type = 'mammal';
    
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
}
```

Данную функциональность можно получить и простым присваиванием классу свойства:

```
User.type = 'mammal';
```

**Статические методы и свойства также наследуются.**

***

### 4. Модульная система работы. Import/export

**Модуль** - отдельный файл, отвечающий за определенную функциональность программы.

#### Зачем нужны модули?

1. Выделение в коде абстракций (устранение необходимости вникать во внутреннюю реализацию
   каждого используемого блока кода);
2. Инкапсуляция кода (скрываем от пользователя нашей абстракции то, что ему не стоит
   видеть/менять);
3. Многократное переиспользование кода;
4. Гибкое управление зависимостями (устранение необходимости переписывать код под каждую
   новую вариацию логики).

> Mодуль представляет собой готовый к переиспользованию фрагмент JavaScript-кода, который экспортирует специальные объекты, доступные для использования в любом зависимом коде.

Для сообщения модулей между собой существуют различные способы:

#### CommonJS

`CommonJS` - модульная система сообщения, созданная для `Node.js`. <br>
В файле `index.js` описываем метод и помещаем его в объект `exports`, который содержит
доступные для сторонних файлов элементы (то есть экспортируем метод из файла):

```
// создаем метод
const mapUsers = (users) => users.map(({ age }) => age);

// экспортируем метод
module.exports = mapUsers;
```

В файле, где мы хотим использовать функцию `mapUsers`, получаем метод с помощью
функции `require`:

```
// импортируем метод
const mapUsers = require('./index.js');

// используем метод
const users = mapUsers(otherUsers);
```

#### ES Modules

`ES Modules` - функционал для работы с модульной системой в современных браузерах.
Работает следующим образом: <br>

В файле `index.js` описываем функционал и экспортируем его с помощью ключевого
слова `export`:

```
// cоздаем метод и массив
const filterData = (data) => filter.map(({ age }) => age > 10);
const mapUsers = users.map(({ age }) => age);

// экспортируем
export { filterData, mapUsers };
```

В файле, где мы хотим использовать функционал, получаем его с помощью ключевого
слова `import`:

```
// Импортируем в другом файле:
import { filterData, mapUsers } from './index.js';

// используем метод/данные
filterData(...
```

Также для удобства один объект можно экспортировать "по-умолчанию"

```
// Экспорт:
export default filterData;

// Импорт:
import filterData from './index.js';
```

Также при экспорте "по-умолчанию" можно не давать имени методу. Подразумевается, что файл
с методом имеет говорящее название. На практике рекомендуется даже при экспорте "
по-умолчанию" давать методу/объекту имя:

```
export default (data) => filter.map(({ age }) => age > 10);
```

Данный способ работы с модулями имеет множество удобных вариантов использования. Вот
некоторые из них:

```
// Можно испортировать все, что было экспортировано в файле:
import * from './index.js';

// Замена имени при импорте
import { filterData, mapUsers as mapper } from './index.js';

// Комбинация дефолтного и обычного импортов
import filterData, { mapUsers } from './index.js';
```

#### Модули в html

Для того чтобы использовать модуль в своем `html`, необходимо сообщить браузеру, что
подключаемый файл является модулем. Сделать это можно добавив атрибут `type="module"` к
тегу `script` с файлом:

```
// Импортируем файл в качестве модуля в html
<script type="module" src="../index.js"></script>

// Используем наш модуль
<script type="module">
    // импортируем нужный метод из подключенного выше модуля
    import filterData from '../index.js';
    
    // используем
    filterData(...);
</script>
```
