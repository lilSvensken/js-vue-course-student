### 1. DOM

Как было сказано в предыдущей теории, все, что мы видим на странице браузера, — `html`.
Чтобы мы могли взаимодействовать с разметкой, была создана специальная модель данными
страницы - `DOM` - если быть точным, **объектная модель документа**

> DOM (от англ. Document Object Model — «объектная модель документа») — это независящий
> от платформы и языка программный интерфейс, позволяющий программам и скриптам получить
> доступ к содержимому HTML-, XHTML- и XML-документов, а также изменять содержимое,
> структуру и оформление таких документов.

Каждый элемент `html`-дерева страницы является объектом. Так, главным объектом является
тег `<html>`, в который вложены другие объекты - теги `<head>` и `<body>`. В эти теги
вложены другие теги и так до бесконечности. В описанной структуре нетрудно узнать дерево.
У нас есть корневой узел (`<html>`) и дочерние узлы, приходящиеся родительскими другим
узлам. И действительно, часто при обсуждении модели документа используется термин <br>
**DOM-дерево**

#### Все в html - DOM-узел

В `DOM` существует 12 типов узлов. Вот самые главные из них:

- `document` (см. ниже)
- узлы-элементы (`hmtl`-теги)
- тестовые узлы - просто текст без обертки в виде тега
- комментарии

***

### 2. Навигация по DOM. Поиск элементов

Точкой входа в `DOM`-дерево является объект `document`. <br>
Для получения `DOM`-элементов в `JS`-коде можно обратиться к этому объекту и
воспользоваться одним из определенных в нем методов.

Разберем три самых важных элемента дерева:

- Верхний узел документа. В `DOM` он соответствует тегу `<html>`:

```
const el = document.documentElement;
```

- Узел тега `body`:

```
const body = document.body;
```

- Узел тега `head`:

```
const body = document.head;
```

Также у каждого элемента мы можем получить его "родителей", "детей" и "соседей":

```
// element - это DOM-объект, соответствующий определенному html-элементу на странице
const parent = element.parentNode;                  // родительский элемент
const nextSibling = element.nextSibling;            // следующий "сосед"
const previousSibling = element.previousSibling;    // предыдущий "сосед"
const firstChild = element.firstChild;              // первый дочерний элемент
const lastChild = element.lastChild;                // последний дочерний элемент

const childNodes = element.childNodes;              // дочерние элементы
```

В данном случае `childNodes` - это набор элементов. Его можно обойти (пройтись по всем его
элементам) следующими способами:

1. Цикл `for of`

```
for (let node of element.childNodes) {
    console.log(node);
}
```

2. Упаковка в массив и последующий обход массива

```
const elements = Array.from(element.childNodes);
// Теперь с elements можно работать как с обычным массивом
// (то есть используя методы filter/map/reduce etc.) 
```

#### `DOM`-селекторы

Для поиска элементов в `DOM`-дереве используются следующие методы:

```
const el = document.querySelector('div.class#id');          // поиск элемента по каким-либо свойствам элемента
const el = document.querySelectorAll('div.class#id');       // поиск всех элементов по каким-либо свойствам

const el = document.getElementById('some-id');              // поиск элемента по id
const el = document.getElementsByTagName('div');            // поиск элемента по типу элемента
const el = document.getElementsByClassName('description');  // поиск элемента по классу
const el = document.getElementsByName('user');              // поиск элемента по атрибуту "name"

const el = element.closest('.content');                     // поиск ближайшего предка
```

***

### 3. Манипулирование DOM

После получения элементов ими можно манипулировать различными способами. Их можно удалять,
добавлять, редактировать, "доставать" из них необходимую информацию и т.д.

В качестве примера рассмотрим следующий `html`:

```
<div class="options">
    <h2 class="options__header">Предложения</h2>
    <ul>
        <li>Элемент 1</li>
        <li>Элемент 2</li>
        <li>Элемент 3</li>
    </ul>
    <span class="otions__footer"></span>
</div>
```

- Получение/запись "внутренностей" элемента: методы `innerHTML`, `textContent`

```
const footer = document.querySelector('.otions__footer');
footer.innerHTML = '<b>Информация</b>';
console.log(footer.innerHTML);  // '<b>Информация</b>'

footer.textContent  = '<b>Информация</b>';
// Определяет содержимое как обычный текст, даже если в нем есть html
console.log(footer.innerHTML);  // '&lt;b&gt;Информация&lt;/b&gt;' - специальные символы были заменены
```

- Создание и вставка `DOM`-узлов

```
const newElement = document.createElement('div');   // создаем тег div
document.body.append(newElement);                   // вставлям элемент последним ребенком в `body`
document.body.prepend(newElement);                  // вставлям элемент первым ребенком в `body`
```

Существуют и другие способы вставки/удаления элементов:

* [Element.before()](https://developer.mozilla.org/en-US/docs/Web/API/Element/before)
* [Element.after()](https://developer.mozilla.org/en-US/docs/Web/API/Element/after)
* [Element.replaceWith()](https://developer.mozilla.org/en-US/docs/Web/API/Element/replaceWith)
* [Element.remove()](https://developer.mozilla.org/en-US/docs/Web/API/Element/remove)

Также после получения `DOM`-узла можно работать не только с его содержимым, но и с его
атрибутами:

```
<div
    class="name description"
    id="main-page"
    data-document-id="125"
    data-color="red"
>
    Текст
</div>

const node = document.querySelector('#main-page');
node.id         // 'main-page'

node.classList.add('group');
node.classList.remove('description');

node.className  // 'name group'
```

Другие методы работы с классами
представлены **[здесь](https://developer.mozilla.org/ru/docs/Web/API/Element/classList)**.

Методы работы с атрибутами в тегах:

- `node.hasAttribute(name)` – наличие атрибута
- `node.getAttribute(name)` – значение атрибута
- `node.setAttribute(name, value)` – установка атрибута
- `node.removeAttribute(name)` – удаление атрибута
- `node.attributes` – получение списка `html` атрибутов

#### Работа с `data`-атрибутами

```
const node = document.querySelector('#main-page');
const documentId = node.dataset.documentId;     // 125 - обращение к атрибуту через camelCase
const color = node.dataset.color;               // 'red'
```

***

### 4. Jquery. Великий и ужасный

**Jquery** - одна из наиболее часто используемых библиотек для работы с `JS`. На фоне
новых фреймворков выглядит безнадежно устаревшей, однако присутствует в огромном
количестве легаси-кода (почти в любом старом проекте). <br> Обладает впечатляющим
арсеналом работы с `JS`. Используется также и для работы с `DOM`-элементами.
**[Официальный сайт](https://jquery.com/)**. <br>

***

### 5. События. Событийная модель. Основные события

**[Документация](https://www.w3.org/TR/DOM-Level-3-Events/)**.

В браузере работает так называемая **событийная модель**. Ее суть заключается в том, что
каждому действию пользователя соответствует определенное событие.<br>
Разработчик имеет возможность определить обработчики для любого события.

Вот наиболее распространенные события и соответствующие им действия:

|        Событие         |                        Действие                         |
|:----------------------:|:-------------------------------------------------------:|
|        `click`         |                 Клик левой кнопкой мыши                 |
|     `contextmenu`      | Клик правой кнопкой мыши <br> (вызов контекстного меню) |
|        `submit`        |                Отправка формы (`<form>`)                |
|        `focus`         |                 Фокусировка на элементе                 |
|      `mousemove`       |                     Движение мышью                      |
| `mouseover / mouseout` |                Наведение мыши на элемент                |
| `mousedown / mouseup`  |               Нажатие/отжатие кнопки мыши               |
|   `keydown / keyup`    |          Нажатие/отжатие кнопки на клавиатуре           |
|   `DOMContentLoaded`   |       `HTML` полностью загружен и готов к работе        |

Навесить на конкретный элемент обработчик события можно различными способами, а именно:

- Описать обработчик в виде специального атрибута `on...` в теге:

```
<div class="example" onclick="alert('Ты нажал')">Нажми на меня</div>
```

Теперь при нажатии на этот элемент отработает код `alert('Ты нажал')`. <br>
Обратите внимание, здесь в кавычках можно написать любой валидный `JS`-код (и оно будет
работать)

Или же с выносом функционала в скрипт (работает аналогично)

```
<script>
    function showAlert() {
        alert('Хватит на меня нажимать!');
    }
</script>

<div class="example" onclick="showAlert()">Нажми на меня</div>
```

Здесь за событие и его обработчик отвечает атрибут `onclick`, в который мы положили
определенный код.<br>
**Данный способ опасен** тем, что злоумышленник может отредактировать данный атрибут у
элемента по своему усмотрению (и выполнить нежелательный код, кликнув по элементу), а это
серьезная брешь в безопасности программы.

- Навесить обработчик на `DOM`-элемент, полученный в коде, через метод `onclick`:

```
const element = document.querySerlector('.example');
element.onclick = showAlert;
// Важно писать без скобок, так как запись element.onclick = showAlert();
// приведет к выполнению функции в момент выполнения этой строки
```

- Навесить обработчик на `DOM`-элемент, полученный в коде, через метод `addEventListener`:

```
const element = document.querySerlector('.example');
element.addEventListener(eventType, handler);
```

Здесь:

- `eventType` - тип события (`click`, `focus` etc.)<br>
- `handler` - функция-обработчик указанного события

Используя `addEventListener`, можно навешать на элемент несколько обработчиков на одно и
то же событие (в случае с `onclick` так сделать не получится, одни обработчики будут
перезаписывать другие).

Удалить обработчик можно, используя метод `removeEventListener`:

```
element.removeEventListener(eventType, handler);
// вторым аргументом важно передать ту же функцию, что мы навесили изначально
```

Обработчик события (`handler`) имеет следующую структуру:

```
const eventHandler = (event) => {
    // обновляем какое-то состояние
    //      или
    // выполняем переход на другую страницу
    //      или
    // манипулируем DOM-элементами
    //      или
    // делаем что-либо еще
}
```

Здесь `event` - это специальный объект, отвечающий за конкретное событие, имеет следующие
ключи:

- `target` - ссылка на `DOM`-элемент, на котором произошло событие
- `currentTarget` - ссылка на `DOM`-элемент, на котором сработал текущий обработчик
- `type` - название события
- `timeStamp` - время совершения события
- `isTrusted` - было ли событие инициировано браузером (например, по клику мышью) или из
  скрипта<br>
  Полное описание и другие свойства
  см. **[здесь](https://developer.mozilla.org/ru/docs/Web/API/Event)**

Пример такого навешивания обработчика события с помощью `addEventListener`:

```
element.addEventListener('click', (event) => {
    // получили элемент, на котором произошло событие
    const currentElement = event.target;

    // как-то используем элемент и его данные
    const currentElementId = currentElement.id;
})
```

***

### 6. Всплытие и погружение

В момент срабатывания события, обработчики срабатывают сначала на текущем `DOM`-элементе,
а затем на его родителе, затем на родителе родителя и так далее.<br>
Данный процесс называется **всплытием**.

Разберем пример:

```
<form onclick="console.log('form')">
    <div onclick="console.log('div')">
        <span onclick="console.log('span')"></span>
    </div>
</form>
```

При клике по элементу `span` в консоль выведется следующее:

```
span
div
form
```

При клике по элементу `div`:

```
div
form
```

И при клике по `form`:

```
form
```

Для предотвращения (остановки) процесса всплытия используется
модификатор `event.stopPropagation()`:

```
<div onclick="console.log('не отработает')">
    <button onclick="event.stopPropagation()">Кнопка</button>
</body>
```

Для остановки всплытия и запрета срабатывания обработчиков на текущем элементе
используется `event.stopImmediatePropagation()`

Помимо "всплытия" есть и стадия "погружения". Полный цикл имеет следующую структуру:

1. Фаза погружения (`capturing phase`) – событие от родителя к ребенку;
2. Целевая фаза (`target phase`) – событие доходит до целевого элемента;
3. Фаза всплытия (`bubbling stage`) – событие идет от ребенка к родителю.

Стадия погружения редко используется в программировании. <br>
Для того, чтобы "отловить" событие на стадии погружения, необходимо использовать третий
аргумент при навешивании на элемент обработчика:

```
element.addEventListener('click', () => ({}), { capture: true });
```

***

### 7. DevTools

**DevTools** - инструменты разработчика, позволяющие отлаживать код в браузере. Вот
основные секции `DevTools` (на примере `Chrome`):

- `Console` - полноценная консоль. В ней доступны все возможности `JS`. Позволяет
  проверять функциональность, вызывать функции, а также выводить промежуточные данные при
  выполнении программы;
- `Elements` - доступ к `DOM`-дереву. Позволяет работать со стилями элементов, а также с
  самими элементами (добавлять/удалять/редактировать/форсировать какие-либо события и
  т.д.);
- `Sources` - раздел для анализа подключенных ресурсов (скриптов, таблиц стилей,
  изображений и т.д.);
- `Network` - раздел для работы с запросами. Здесь можно анализировать отправляемые
  запросы, получаемые ответы, а также моделировать различные условия выполнения кода в
  браузере (например, замедлять интернет);
- etc.

Помимо вкладок по умолчанию в `DevTools` можно добавить нужные Вам инструменты, например
инструменты работы с фреймворками:

- **[Vue.js devtools](https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd)**
- **[Redux DevTools](https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?hl=ru)**
- и другие

***

### 8. Ревью кода

Грамотное ревью кода - огромный плюс для проекта.<br>

> Код пишется людьми для людей

При первом просмотре кода проверяется грамотность принятых архитектурных решений. Основная
часть небольших ошибок реализации оставляется за скобками, так как некоторые ошибки могут
быть исправлены автоматически при изменении основных решений.<br> При дальнейших
просмотрах, когда основные архитектурные вопросы решены, ревьювер анализирует код на более
низком уровне.

Основные моменты, на которые ревьювер обращает внимание при проверке кода:

- Решение не должно ломать уже существующий функционал. Добавить фичу - здорово, но только
  если она не заставит перестать работать другую фичу;
- Имя коммита должно содержать ссылку на соответствующую задачу в агрегаторе задач Вашей
  организации (например, в `Phabricator`, `Jira`);
- Описание коммита должно быть кратким описанием сделанного. История `git` - очень важная
  вещь, особенно в больших проектах;
- Имена переменных должны иметь корректную семантику. Имена функций `f`, `myFunction`
  , `dobavit_tekst` - плохо;
- Стиль именования сущностей должен соответствовать принятому в проекте. Если в файле все
  именуется через `camelCase`, то свою функцию не стоит именовать через `snake_case`;
- Каждый коммит - выполненная задача. Если Вы хотите сделать рефакторинг кода в рамках
  задачи по добавлению нового функционала, сделайте два отдельных коммита: один для самого
  функционала, второй - для рефакторинга;
- Соблюдение стиля кодирования, принятого в проекте - отступы, пробелы, переносы;
- Выделение в коде грамотных абстракций. Если Ваша функция отлично работает, но абсолютно
  бесполезна в контексте данного кода - функция избыточна;
- Решение достаточно компактно. Лучший код тот, которого нет...;
- Решение достаточно расширяемо. Ваш код может работать, однако если он исключает
  возможность своего расширения (если оно возможно в будущем) - это плохой код;
- Решение достаточно кроссбраузерно. Если Ваш проект поддерживает `IE` - нужно
  позаботиться об этом;
- В коде отсутствует "мусор" - личные комментарии разработчика, элементы отладки
  (например, `console.log` и другие дебаггеры);
- etc.
