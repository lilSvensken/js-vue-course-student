### 1. Введение в `HTML`

`HTML` (**HyperText Markup Language** — «язык гипертекстовой разметки») — базовый
строительный блок веб-интерфейса. Он определяет содержание и структуру контента. Для
описания внешнего вида/представления веб-страницы используется `CSS`, в для определения
функциональности/поведения - `JavaScript`.

Всё, что Вы видите на странице в браузере - `html`.

`HTML` - язык, однако на странице он только размечает данные, но никак с ними не
взаимодействует.

Разметку страницы можно посмотреть, нажав сочетание клавиш `Ctrl + U` (`Cmd + Option + U`
на macOS), а также открыв консоль разработчика и перейдя в раздел "Элементы".

#### Теги

Теги - основной строительный материал в `html`. Для того чтобы отобразить элемент, его
необходимо положить в какой-либо тег. Выведем на страницу, например, параграф:

```
<p>Общая информация</p>
```

Здесь `<p>` - открывающий тег, `</p>` - закрывающий. Тег `p` - парный.

Существуют также и непарные теги, например, ```<input/>``` - поле ввода текста.

Блоки могут вкладываться друг в друга. Это позволяет позиционировать их на странице так,
как задумал дизайнер (или Вы сами).<br> Например, разместим ссылку и заголовок в шапке
страницы:

```
<div>
    <h2>Первая ставка бесплатно!</h2>
    Заходи <a href="https://stavki-na-sport.com">сюда</a>!
</div>
```

Существующие теги можно
посмотреть **[здесь](https://developer.mozilla.org/ru/docs/Web/HTML/Element)**

#### Атрибуты

Одной из важнейших составляющих тегов являются **атрибуты** - данные, помещенные в теги

Рассмотрим пример:

```
<a href="https://some-href">сюда</a>
```

Здесь:

- `href` - имя атрибута, а данном случае ссылка
- `https://some-href` - значение атрибута, сама ссылка

Самые популярные атрибуты:

- `class` - класс элемента. Используются для стилевого оформления и иногда для работы
  скриптов;
- `id` - идентификатор тега. Уникален на странице. Используется для поиска элементов на
  странице и иногда для выстраивания работы стилей;
- `style` - `css`-стили элемента.

Помимо них существует большое количество специфических атрибутов, используемых на
определенных тегах. <br>
Например, для создания чекбокса необходимо создать тег `<input/>` с
атрибутом `type="checkbox"`

#### Блочная модель

При формировании `html`-каркаса страницы некоторые блоки будут отвечать непосредственно за
каркас. Называются такие элементы **блочными**. Другие же элементы будут отвечать за
функциональность и стилистическое оформление. Они называются **строчными**.

В `html` по умолчанию есть блочные и строчные элементы (каждый тег по определению либо
блочный, либо строчный), однако разработчик может решить, что какой-либо элемент будет
строчным, а не блочным (вопреки изначальной задумке). Для этого необходимо настроить `css`
-свойство `display`.

#### Блочные элементы в HTML (`block`)

- `<address>`
- `<blockquote>`
- `<div>`
- `<fieldset>`
- `<form>`
- `<h1> , ... , <h6>`
- `<hr>`
- `<ol>`
- `<ul>`
- `<p>`
- `<pre>`
- `<table>`

Блочные элементы занимают всю доступную им ширину родителя. Другие элементы в пределах
этого же родителя будут располагаться либо выше этого элемента, либо ниже.

Пример: здесь каждый элемент будет располагаться на новой строке

```
<div> 4 </div>
<div> 8 </div>
<div> 15 </div>
<div> 16 </div>
<div> 23 </div>
<div> 42 </div>
```

В блочные элементы можно вкладывать как другие блочные, так и строчные элементы.

#### Строчные элементы в HTML (`inline`)

- `<img>`
- `<span>`
- `<a>`
- `<q>`
- `<code>`

Строчные элементы занимают только ту ширину, которая им необходима для корректного вывода,
поэтому соседние элементы не переносятся на новые строки.

Пример: здесь каждый элемент будет располагаться на той строке, что и остальные

```
<span>Пять </span>
<span>минут, </span>
<span>Турецкий!</span>
```

**В строчные элементы можно вкладывать только другие строчные элементы**.

#### Семантика расположения элементов на странице

**Семантическая верстка** - способ сделать Вашу страницу более понятной для других
разработчиков, а также для пользователей с ограниченными возможностями, например,
слабовидящих.

Задание на дом - ознакомиться с
принципами [семантической верстки](https://medium.com/@stasonmars/секреты-использования-семантической-верстки-html5-c7cd5e6f1ebb)

***

### 2. Введение в `CSS`

`CSS` (Cascading Style Sheets) — это таблица стилей, в которой будет настраиваться внешний
вид тегов на странице.

#### Как подключить `CSS`

Подключить `CSS` можно следующими способами:

- Подключить файл с расширением `.css`
  Для этого необходимо добавить в шапку страницы в тег `head` тег `link`

```
<link
    rel="stylesheet"
    type="text/css"
    href="./index.css"
>
```

- Использовать тег `style` в файле

```
<style>
    div {
        color: black;
    }
</style>
```

- Использовать атрибут `style` внутри нужного тега:

```
<div style="color: black;">
    Хоба!
</div>
```

#### Селекторы

Селекторы в `CSS` - способ дать таблице стилей понять, к какому элементу применять данные
стили.

Для создания селектора можно использовать любые данные, хранящиеся в теге, но чаще всего
используются следующие:

- `element` - в данном случае стили применяются ко всем элементам данного типа

```
h1 {
    border: 1px solid red;
}
```

- `class` - идет поиск по классу. Записывается через `.`

```
// Стили применятся ко всем элементам с классом `main-container`
.main-content {
    border: 1px solid red;
}
```

- `id` - поиск по идентификатору. Записывается через `#`

```
#item-42 {
    border: 1px solid red;
}
```

Селекторы можно комбинировать и вкладывать друг в друга:

```
// работает для всех тегов `div`, у которых есть класс `main-content`
div.main-content { 
    border: 1px solid red;
}

// работает для всех тегов `li`, находящихся внутри элемента с классом `main`
.main li {
    margin: auto;
}

// работает для всех тегов `h3`, находящихся непосредственно внутри элемента
// с классом `minor` (только на первом уровне вложенности)
.minor > h3 {
    padding: 10px;
}
```

#### Стили

Сами стили могут настраивать огромное множество свойств элементов, например:

- `margin` - внешние отступы в блоке;
- `padding` - внутренние отступы в блоке;
- `border` - границы элемента;
- `position` - позиционирование элемента на странице;
- `font` - настройки стиля текста;
- `height`, `width`, `min-height`, `max-width` - размеры элемента;
- `background` - настройка фона элемента;
- `color` - настройка цвета текста;
- etc

Стили работают по-разному в разных условиях. Также они могут перекрываться друг другом -
это называется "каскадность" стилей.

#### Каскадность стилей

При объявлении на странице нескольких селекторов, отвечающих за внешний вид одного и того
же элемента, `CSS` будет брать наиболее приоритетный из них. Например:

```
p {
    color: red;
    margin: auto;
}

p {
    color: black;
}
```

В данном примере все параграфы на странице будут с черным текстом, потому что первый
стиль `color: red;` **перезаписался ниже идущим** стилем `color: black;`.

Однако не всегда расположенный ниже стиль будет более приоритетным

#### Специфичность селекторов

Как мы уже знаем, селекторы бывают разных типов - классы, идентификаторы, элементы и
т.д. <br>
Комбинация этих сущностей и будет определять, какой стиль обладает более высоким
приоритетом.

|         Селектор         |  Вес   |
|:------------------------:|:------:|
| Элементы, псевдоэлементы |  `1`   |
|      Класс, атрибут      |  `10`  |
|      Идентификатор       | `100`  |
|       Инлайн-стиль       | `1000` |

Рассмотрим примеры:

|                Селектор                 | id  | class | element | Общий вес  |
|:---------------------------------------:|:---:|:-----:|:-------:|:----------:|
|                  `div`                  | `0` |  `0`  |   `1`   |    `1`     |
|                 `.main`                 | `0` |  `1`  |   `0`   |    `10`    |
|               `div.main`                | `0` |  `1`  |   `1`   |    `11`    |
|                 `#item`                 | `1` |  `0`  |   `0`   |   `100`    |
|             `div.main#item`             | `1` |  `1`  |   `1`   |   `111`    |
|               `div span`                | `0` |  `0`  |   `2`   |    `2`     |
| `div.main#item span.minor.data-item p`  | `1` |  `3`  |   `3`   |   `133`    |

Также приоритет стиля можно повысить с помощью `!important`

```
p {
    color: red !important;
}

p {
    color: black;
}
```

В данном примере текст выведется красным цветом.

Использование `!important` довольно опасно в большинстве случаев, так как может привести к
невозможности переопределения стилей при необходимости. **Пользуйтесь этим способом
осторожно и только при крайней необходимости.**

***

### 3. Методологии формирования системы классов в `CSS`

Существует множество разных способов организовать именование классов в `html`. Каждый из
них обладает своими преимуществами и недостатками - единственно верной методологии пока не
изобрели.

Вот некоторые из существующих методологий:

- [Атомарный CSS](https://ornaorg.github.io/AtomicCSS.html)
- [Многослойный CSS](https://wsd.events/2012/10/27/pres/mcss/)
- **БЭМ**
- etc

#### Основы методологии БЭМ. Семантика блоков в `CSS`. Правила именования

**БЭМ** - Блок Элемент Модификатор.

Основная суть данной методологии заключается в том, что при именовании классов
используется семантика элементов. <br>
Глядя на грамотно спроектированный по БЭМ `html`, разработчик может сразу понять, какие
сущности находятся на странице.

Допустим, на странице есть **блок** навигационных кнопок. Нам также известно, что данный
блок может использоваться сразу в нескольких местах. При этом стили блока в каждом
вхождении будут идентичны. Определим имя класса для всего блока как `navigation` - в имени
заложим семантическую суть данного блока - это навигация.

```
<div class="navigation"></div>
```

Теперь разместим в этом блоке несколько кнопок (это наши **элементы**). <br>
Каждому **элементу** дадим класс с учетом того, что его родитель - блок `navigation`.<br>
Например, `navigation__button` - через 2 нижних подчеркивания.

```
<div class="navigation">
    <button class="navigation__button">
        Организационное
    </button>
    <button class="navigation__button">
        Наши сотрудники
    </button>
    <button class="navigation__button">
        Контакты
    </button>
</div>
```

Отлично, теперь при взгляде на верстку сразу понятно, что перед нами навигационный блок,
где каждый внутренний элемент - навигационная кнопка.

В дизайне первая кнопка имеет бОльший размер и другой цвет, так что нам необходимо ее
как-то выделить. <br> На данном этапе стоит добавить **модификатор** кнопки. Пусть первая
кнопка будет главной, добавим ей класс `navigation__button--main`, где `main` -
модификатор, сообщающий нам, что это разновидность "главная" навигационной кнопки.<br>
В `html` это будет выглядеть следующим образом:

```
<div class="navigation">
    <button class="navigation__button navigation__button--main">
        Организационное
    </button>
    <button class="navigation__button">
        Наши сотрудники
    </button>
    <button class="navigation__button">
        Контакты
    </button>
</div>
```

Таблица стилей может выглядеть следующим образом:

```
.navigation {
    display: flex;
    border-radius: 10px;
}

.navigation__button {
    color: #000;
    background: #ffeed6;
    margin: 5px;
    padding: 5px;
}

.navigation__button--main {
    background: #ff9090;
    padding: 10px;
}
```

Таким образом в классе `navigation__button--main`:

- `navigation` - имя блока
- `button` - имя элемента, пишется через `__`
- `main` - имя модификатора, пишется через `--`

Внутри блоки, элементы, модификаторы разделяются знаком `-` -
например, `user-item__button--no-data`. <br>
Если появляется необходимость в элементе добавить внутрь еще один элемент, в его имени
лучше не использовать имя элемента-родителя, например:

```
<div class="cards-block">
    <div class="cards-block__card">
        <h3 class="cards-block__card-header">
            Личные документы
        </h3>
        <span class="cards-block__card-description">
            Здесь Вы можете ознакомиться с документацией
        </span>
    <div>
</div>
```

***

### 4. Сборка фронтенда. Webpack

Теперь, когда мы познакомились с основными структурными элементами построения
веб-интерфейсов (`js`, `html`, `css`), важно разобраться в том, как всё это соединить в
работающую программу.<br>

Фронтенд-часть приложения чаще всего состоит из большого количества модулей (
см. `Lesson 03`), которые нужно подготовить к отправке в браузер. Это необходимо потому,
что:

- Модульная система импортов не работает в старых браузерах
  (см **[caniuse modules](https://caniuse.com/?search=modules)**);
- Солидная часть методов также не работает в ряде браузеров, поэтому нам необходимо
  преобразовать данные методы в их более старые аналоги. Для этого
  используются **[полифиллы](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%BB%D0%B8%D1%84%D0%B8%D0%BB)**
- Для работы с кодом браузеру не нужны наши комментарии и другие избыточные сущности;
- Для `development` и `production` код должен обладать разными свойствами (в режиме
  разработки - информативностью, для готового сайта - легковесностью, быстротой работы).

Данную проблему решают специальные библиотеки - сборщики фронтенда:

- **[Webpack](https://webpack.js.org/)**
- **[Vite](https://github.com/vitejs/vite)**
- **[Browserfy](https://browserify.org/)**
- **[Esbuild](https://esbuild.github.io/)**
- etc

Сборщики фронтенда позволяют гибко настраивать сборку (`build`) модулей в единое целое

Разные сборщики выполняют свою работу с разной скоростью. Так, например, самым быстрым
считается сборщик `esbuild` (по крайней мере по их собственным замерам). Однако для
изучения сборки мы будем рассматривать библиотеку `webpack`, так как в ней меньше "
синтаксического сахара" и она используется в огромном количестве проектов.

Для начала библиотеку необходимо установить:

```
yarn add -D webpack
```

Теперь разберемся с использованием. Допустим, наше приложение состоит из файла `index.js`,
куда импортируются методы из файлов `js/utils.js` и `js/api.js`, и файла
стилей `styles.css`. Файл `index.js` будет выглядеть следующим образом:

```
// импортируем методы для работы приложения
import getUsers from '@/utils.js';
import api from '@/api.js';

// импортируем стили
import '../styles.css';

// какой-то код
```

Официальный сайт `Webpack` предлагает нам описать логику сборки в специальном
файле `webpack.config.js`:

```
// Импортируем плагины, вспомогательные библиотеки
const path = require('path');
const EncodingPlugin = require('webpack-encoding-plugin');
const MomentLocalesPlugin = require('moment-locales-webpack-plugin');

module.exports = {
    // тип сборки - для разработки или в продакшн
    mode: process.env.NODE_ENV || 'development',
    
    // "точка входа" в приложение. Это коренвой js-файл функционала, к нему подключаются остальные файлы
    entry: {
        'core': './js/index.js'
    },
    
    // директория, в которой будет лежать build (наша сборка)
    output: {
        path: path.resolve(__dirname, './js/build/'),
        filename: '[name].bundle.js',
    },
    
    module: {
        // правила для трансформации файлов разных расширений
        rules: [
            // `js`-файлы должны обработаться спецальным лоадером, который преобразует "новый" код в "старый"
            {
                test: /\.js$/,
                loader: 'babel-loader',
                exclude: path.resolve(__dirname, './node_modules/')
            },
            // `css`-файлы имеют внутри импорты, которые тоже нужно обработать
            {
                test: /\.css$/,
                use: [
                    'css-loader'     // работа с импортами
                    'style-loader',  // добавление стилей в DOM-дерево
                ]
            },
        ]
    },
    
    // Подключаем плагины для работы с языками, кодировками и т.д.
    plugins: [
        new EncodingPlugin({
            encoding: 'cp-1251'
        }),
        new MomentLocalesPlugin({
            localesToKeep: ['ru'],
        }),
    ],
    
    resolve: {
        // настраиваем сокращения для удобной разработки
        alias: {
            '@': path.resolve(__dirname, 'js/')
        }
    },
    
    // настраиваем инструменты разработчика для каждого мода
    devtool: developmentMode ? 'eval-source-map' : 'cheap-source-map'
};
```

После настройки конфигурационного файла и написания кода, можно запустить процесс сборки:
В командной строке запускаем команду:

```
webpack
```

Для удобства разработки в файле `package.json` можно настроить специальные команды для
запуска в `development` и `production` режимах:

```
"scripts": {
    "watch": "webpack -w --mode development",  // для разработки
    "build": "webpack -p --mode production",   // для итоговой сборки в продакшн
},
```

Здесь флаг `-w` добавлен для включения `watch`-режима (отслеживает изменения в рабочей
директории и сам запускает пересборку):

В результате мы получаем файл `core.bundle.js`, лежащий в директории `/js/build`. Остается
только подключить данный файл к странице.<br>
Для этого в `html` страницы необходимо добавить тег `script` со ссылкой на наш файл
сборки:

```
<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8" />
        ...
    </head>
    <body>
        ...
        <script src="js/build/core.bundle.js"></script>
    </body>
</html>
```

Отлично, простейшая сборка готова.

Чтобы закрепить материал, в отдельной директории на своем ПК создайте с помощью `webpack`
приложение, отображающее на странице текст `НЕВЕРОЯТНО, ОНО ЗАРАБОТАЛО! Я ГЕНИЙ!`

**PS.** Темы для самостоятельного изучения:

- **[Padding](https://developer.mozilla.org/en-US/docs/Web/CSS/padding)**
- **[Margin](https://developer.mozilla.org/ru/docs/Web/CSS/margin)**
- **[Flexbox](https://developer.mozilla.org/ru/docs/Web/CSS/flex)**
- **[Border](https://developer.mozilla.org/ru/docs/Web/CSS/border)**